<!DOCTYPE html>
 
<!--

This is derived from the Wacom Scribble Demo: https://github.com/Wacom-Developer/wacom-device-kit-web

Key differences
- Basic cleanup and refactoring
- Does not have different brushs colors. The brush colors are static.
- Removed any IE-specific code

-->
<html>
<head>
	<title>7P HTML Tablet tester</title>
	<style>

		* {
			font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
		}

		h1, h2, h3, p {
			padding: 0;
			margin: 0;
		}

		.canvasDiv {
			text-align: center;
			margin-left: auto;
			margin-right: auto;
		}

		div {
			/*border: 1px solid black;*/
			padding: 5px;
			padding-top: 5px;
			margin-bottom: 5px;
		}

		#myCanvas {
			touch-action: none; /*prevent canvas scrolling and system touch behavior*/
			display: block;
			/* This doesn't ensure background color saved in image.
				background-color: tan;
				See https://stackoverflow.com/questions/6957034/save-canvas-with-background-image
			*/
		}
	</style>
</head>
<body onload="initPage()" onresize="setCanvasProps()" oncontextmenu="return false;">
	<div class='parent'>
		<h2 >7P Tablet Tester</h2>
		<p>
			<a href="https://thesevenpens.github.io/HtmlTabletTester/" target="_blank" rel="noopener noreferrer" >Documentation</a>
			|
			<a href="https://github.com/TheSevenPens/HtmlTabletTester" target="_blank" rel="noopener noreferrer" >GitHub repo</a>

		</p>


	</div>

	<div>
		<button type="button" onclick="clearCanvas()">Clear</button>
		<button type="button" onclick="saveCanvas()">Save</button>
		
		<input type="checkbox" id="tiltCheckbox" value="useTilt" onclick="update_paint_settings_from_ui()">
		<label for="tiltCheckbox" >Enable tilt</label>

		<input type="checkbox" id="pressureCheckbox" value="usePressure" onclick="update_paint_settings_from_ui()" checked>
		<label for="pressureCheckbox">Enable pressure</label>
	</div>

	<div class="canvasDiv">
		<canvas id="myCanvas" height="800" style="border:5px solid #d1d1d1;">
			Your browser does not support the canvas element.
		</canvas>
	</div>

	<a id="link"></a>

	<script>
		/////////////////////////////////////////////////////////////////////////

		function new_range(min,max)
		{
			var r ={ 
				Min: min,
				Max: max 
			}
			return r;
		}

		const setting_stylus_pen_color = "black";
		const setting_canvas_color = "rgba(230, 230, 250, 1.0)";

		const setting_download_filename = "TabletTester_Untitled.png";
		const setting_linecap = "round";

		var paint_settings = 
		{
			use_tilt: false,
			use_pressure: false,
			brush_size: 30,
			eraser_size: 30

		};

		const PRESSURE_RANGE = new_range(0.0,1.0);
		const BRUSHSIZE_RANGE = new_range(1.0,100.0);


		var myCanvas = document.getElementById("myCanvas");
		var context = myCanvas.getContext("2d");
		var inStroke = false;
		var canvas_pos_old = { x: 0, y: 0 };
		var isDrawing = false;

		update_paint_settings_from_ui(); 

		var EPenButton =
			{
				tip: 0x1,		// left mouse, touch contact, pen contact
				barrel: 0x2,		// right mouse, pen barrel button
				middle: 0x4,		// middle mouse
				eraser: 0x20		// pen eraser button
			};


		/////////////////////////////////////////////////////////////////////////
		// Initialize page elements
		//
		function initPage() 
		{
			setCanvasProps();
		}

		/////////////////////////////////////////////////////////////////////////


		/////////////////////////////////////////////////////////////////////////
		// Init canvas properties.
		// Sets canvas width to expand to browser window.
		// Canvas cleared to restore background color.
		//
		function setCanvasProps() 
		{
			if (myCanvas.width < window.innerWidth) 
			{
				myCanvas.width = window.innerWidth - 50;
			}
			clearCanvas();	// ensures background saved with drawn image
		}

		/////////////////////////////////////////////////////////////////////////
		// Sets a flag to enable/disable use of the pen tilt property.
		//
		function update_paint_settings_from_ui() 
		{
			var use_tilt = document.querySelector('input[value="useTilt"]');
			var use_pressure = document.querySelector('input[value="usePressure"]');

			paint_settings.use_tilt = use_tilt.checked;
			paint_settings.use_pressure = use_pressure.checked;
		}


		/////////////////////////////////////////////////////////////////////////
		// Clears the drawing canvas.
		//
		function clearCanvas() 
		{
			context.fillStyle = setting_canvas_color;
			context.fillRect(0, 0, myCanvas.width, myCanvas.height);
		}

		/////////////////////////////////////////////////////////////////////////
		// Saves the image on the drawing canvas and then downloads a png.
		//
		function saveCanvas() 
		{
			var link = document.getElementById('link');
			var url = myCanvas.toDataURL("image/png").replace("image/png", "image/octet-stream");
			link.setAttribute('download', setting_download_filename );
			link.setAttribute('href', url);
			link.click();
		}


		/////////////////////////////////////////////////////////////////////////
		// clamp 
		//
		function clamp(v, lower, upper) 
		{
				return Math.min(Math.max(v, lower), upper);
		}

		/////////////////////////////////////////////////////////////////////////
		// clamp to range
		//
		function clamp_to_range(v, r) 
		{
				return clamp(v, r.Min, r.Max);
		}
		
		/////////////////////////////////////////////////////////////////////////
		// Linear interpolate between two values
		//
		function lerp(a, b, t ) 
		{
			var c = (a * t) + (b * (1-t));
			return c;
		}

		/////////////////////////////////////////////////////////////////////////
		// Linear interpolate between two points
		//
		function lerp_point(a, b, t) 
		{
			var p = 
			{
				x: lerp(a.x, b.x, t),
				y: lerp(a.y, b.y, t)
			};

			return p;
		}

		/////////////////////////////////////////////////////////////////////////
		// Create a new 2D position object
		//
		function new_pos( nx, ny)
		{
			var pos =
			{
				x: nx,
				y: ny
			};
			return pos;
		}

		function get_effective_brush_size( paint_rec )
		{
			// If the brush size is not dynamic,
			// simply use the the user's
			// desired brush size
			if (!paint_settings.use_pressure && !paint_settings.use_tilt)
			{
				return paint_settings.brush_size;
			}

			// the brush size is dynamic
			// start with what the user wants
			var new_size = paint_settings.brush_size;
			
			// then scale the brush size by the pressure value
			if (paint_settings.use_pressure)
			{
				new_size = new_size * paint_rec.pressure; 
				new_size = clamp_to_range( new_size, BRUSHSIZE_RANGE )
			}

			// then apply tilt
			// NOTE: in this app the "brush" is a circle
			// For now simply increase the size of the brush
			// as the pen is more tilted
 			var tilt_amt = Math.max( Math.abs(paint_rec.tilt.x), Math.abs(paint_rec.tilt.y) )
			if (paint_settings.use_tilt)
			{
				var max_tilt = 60.0;
				var normalized_tilt = tilt_amt/max_tilt;
				 new_size = new_size * normalized_tilt;
				new_size = clamp_to_range( new_size, BRUSHSIZE_RANGE )
			}

			return new_size;
		}


		function get_pen_color( evt )
		{
			if (evt.pointerType == "pen")
			{
				return (evt.buttons == EPenButton.eraser) ? setting_canvas_color : setting_stylus_pen_color;
			}
			return setting_stylus_pen_color;
		}

		function get_pressure( evt )
		{
			var p =  (evt.pointerType == "pen") ? evt.pressure : PRESSURE_RANGE.Max;  
			p = clamp_to_range( p, PRESSURE_RANGE);
			return p;
		}


		/////////////////////////////////////////////////////////////////////////
		// Handle drawing for HTML5 Pointer Events.
		//
		function pointer_event_handler(ptr_event) 
		{
			var canvas_rect = myCanvas.getBoundingClientRect();

			var pointer_rec = 
			{
				screen_pos: new_pos(ptr_event.clientX, ptr_event.clientY),
				canvas_pos: new_pos(ptr_event.clientX - canvas_rect.left, ptr_event.clientY - canvas_rect.top),
				pressure: get_pressure(ptr_event),
				buttons: ptr_event.buttons,
				tilt: 
					{ 
						x: ptr_event.tiltX,
						y: ptr_event.tiltY
					},
				rotate: ptr_event.twist,
			}

			if (ptr_event.pointerType) 
			{

				switch (ptr_event.type) 
				{
					case "pointerdown":
						isDrawing = true;
						canvas_pos_old = pointer_rec.canvas_pos;
						break;

					case "pointerup":
						isDrawing = false;
						break;

					case "pointermove":
						if (!isDrawing) 
						{
							return;
						}
						context.lineWidth = get_effective_brush_size(pointer_rec);
						context.strokeStyle = get_pen_color(ptr_event);
						if (pointer_rec.buttons == EPenButton.eraser) 
						{
							context.fillRect(
								pointer_rec.canvas_pos.x, 
								pointer_rec.canvas_pos.y, 
								paint_settings.eraser_size, paint_settings.eraser_size);
							context.fill();
						}
						else if (pointer_rec.pressure > 0) 
						{
							context.beginPath();
							context.lineCap = setting_linecap;
							context.moveTo(canvas_pos_old.x, canvas_pos_old.y);

							// Draws Bezier curve from context position to midPoint.
							var midPoint = lerp_point(canvas_pos_old, pointer_rec.canvas_pos, 0.5);
							context.quadraticCurveTo(canvas_pos_old.x, canvas_pos_old.y, midPoint.x, midPoint.y);
							context.lineTo(pointer_rec.canvas_pos.x, pointer_rec.canvas_pos.y);
							context.stroke();
						}

						canvas_pos_old = pointer_rec.canvas_pos;
						break;

					case "pointerenter":
						document.body.style.cursor = "crosshair";
						break;

					case "pointerleave":
						document.body.style.cursor = "default";
						break;
					case "pointerover":
						// ignore
						break;
					case "pointerout":
						// ignore
						break;
					case "gotpointercapture":
						// ignore
						break;
					case "lostpointercapture":
						// ignore
						break;
					default:
						console.log("WARNING: unhandled event: " + ptr_event.type);
						break;
				}
			}
		}


		/////////////////////////////////////////////////////////////////////////
		// Upon a window load event, registers all events.
		//
		function register_pointer_event_handlers()
		{
		

			window.addEventListener('load', function () 
			{
				if (!window.PointerEvent) 
				{
					console.log("INFO: Browser DOES NOT support pointer events");
					return;
				}

				console.log("INFO: Browser DOES support pointer events");

				// HTML5 PointerEvent events.
				var pointerEvents = [
					'pointerdown',
					'pointerup',
					'pointercancel',
					'pointermove',
					'pointerover',
					'pointerout',
					'pointerenter',
					'pointerleave',
					'gotpointercapture',
					'lostpointercapture'
				];

				for (var idx = 0; idx < pointerEvents.length; idx++) 
				{
					myCanvas.addEventListener(pointerEvents[idx], pointer_event_handler, false);
				}


			}, true);  
		}

		register_pointer_event_handlers();

	</script>

</body>
</html>
